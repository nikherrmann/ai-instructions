#!/usr/bin/env bash
#
# instr - AI Instruction Manager
#
# Manages instruction files for AI coding assistants (Claude Code, GitHub Copilot).
# Uses symlinks from project .github/instructions/ to a central library.
#
# Usage:
#   instr list                    - List available instructions
#   instr show [project]          - Show what instructions a project loads
#   instr sync [project|--all]    - Sync instruction symlinks
#   instr add <project> <set>     - Add instruction set (domain:name or tool:name)
#   instr remove <project> <file> - Remove an instruction symlink
#   instr pick [project]          - Interactive picker to add instructions
#   instr upload <file> <domain>  - Upload local file to domain, symlink everywhere
#   instr check [project|--all]   - Check for broken symlinks
#   instr audit                   - Find local files that could be centralized
#
# Examples:
#   instr list                    # Show all available instructions
#   instr show                    # Show current project's instructions
#   instr sync .                  # Sync current project
#   instr add . domain:web        # Add web domain to current project
#   instr pick                    # Interactive picker
#   instr upload local.md web     # Move local file to web domain
#
set -euo pipefail

# Configuration
CENTRAL_LIB="${AI_INSTRUCTIONS_DIR:-$HOME/.ai-instructions}"
CONFIG_FILE="${CENTRAL_LIB}/config.yaml"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m'

# Helpers
log() { echo -e "${BLUE}==>${NC} $*"; }
success() { echo -e "${GREEN}✓${NC} $*"; }
warn() { echo -e "${YELLOW}!${NC} $*"; }
error() { echo -e "${RED}✗${NC} $*" >&2; }
dim() { echo -e "${DIM}$*${NC}"; }

# Check if central library exists
check_setup() {
    if [[ ! -d "$CENTRAL_LIB" ]]; then
        error "AI Instructions not set up."
        echo ""
        echo "Run the setup script first:"
        echo "  ./setup.sh"
        echo ""
        echo "Or set AI_INSTRUCTIONS_DIR to your instruction library location."
        exit 1
    fi
}

# Resolve project path
resolve_project() {
    local input="${1:-.}"

    if [[ "$input" == "." ]]; then
        pwd
    elif [[ "$input" == /* ]]; then
        echo "$input"
    elif [[ -d "$input" ]]; then
        cd "$input" && pwd
    else
        echo "$input"
    fi
}

# Get category from project (reads from .ai-category file or config routing)
get_category() {
    local path="$1"

    # Check for explicit category file
    if [[ -f "$path/.ai-category" ]]; then
        cat "$path/.ai-category"
        return
    fi

    # Default to "default"
    echo "default"
}

# Get default instruction sets for a category
get_default_sets() {
    local category="$1"

    # Read from config if available
    if [[ -f "$CONFIG_FILE" ]] && command -v yq &>/dev/null; then
        local core domains tools
        core=$(yq -r ".categories.${category}.core // [] | join(\",\")" "$CONFIG_FILE" 2>/dev/null || echo "")
        domains=$(yq -r ".categories.${category}.domains // [] | join(\",\")" "$CONFIG_FILE" 2>/dev/null || echo "")
        tools=$(yq -r ".categories.${category}.tools // [] | join(\",\")" "$CONFIG_FILE" 2>/dev/null || echo "")

        local result=""
        [[ -n "$core" ]] && result="core:$core"
        [[ -n "$domains" ]] && result="$result domain:$domains"
        [[ -n "$tools" ]] && result="$result tool:$tools"
        echo "$result"
        return
    fi

    # Fallback defaults
    case $category in
        web)      echo "core:coding-standards domain:web tool:docker" ;;
        backend)  echo "core:coding-standards domain:backend tool:docker" ;;
        infra)    echo "core:coding-standards domain:devops tool:docker,terraform" ;;
        bare)     echo "" ;;  # Nothing auto-loaded
        *)        echo "core:coding-standards" ;;
    esac
}

# Calculate relative path from project to central library
get_relative_path() {
    local project_path="$1"
    local target="$2"

    # Use realpath if available, otherwise calculate manually
    if command -v realpath &>/dev/null; then
        realpath --relative-to="$project_path/.github/instructions" "$target"
    else
        # Fallback: count depth and construct path
        local depth=$(echo "$project_path" | tr -cd '/' | wc -c)
        local prefix=$(printf '../%.0s' $(seq 1 $((depth + 2))))
        echo "${prefix}${target#$HOME/}"
    fi
}

#------------------------------------------------------------------------------
# Command: list
#------------------------------------------------------------------------------
cmd_list() {
    check_setup

    echo ""
    echo -e "${CYAN}Available Instructions${NC}"
    echo "────────────────────────────────────────"

    # Core files
    if [[ -d "${CENTRAL_LIB}/core" ]]; then
        echo ""
        echo -e "${BLUE}Core${NC} (core/)"
        for f in "${CENTRAL_LIB}/core"/*.md; do
            [[ -f "$f" ]] || continue
            local name=$(basename "$f" .md)
            local lines=$(wc -l < "$f")
            printf "  %-30s %s\n" "$name" "${DIM}(${lines} lines)${NC}"
        done
    fi

    # Domain files
    if [[ -d "${CENTRAL_LIB}/domains" ]]; then
        echo ""
        echo -e "${BLUE}Domains${NC} (domains/)"
        for domain_dir in "${CENTRAL_LIB}/domains"/*/; do
            [[ -d "$domain_dir" ]] || continue
            local domain=$(basename "$domain_dir")
            echo -e "  ${GREEN}$domain/${NC}"
            for f in "$domain_dir"*.md; do
                [[ -f "$f" ]] || continue
                local name=$(basename "$f" .md)
                local lines=$(wc -l < "$f")
                printf "    %-28s %s\n" "$name" "${DIM}(${lines} lines)${NC}"
            done
        done
    fi

    # Tool files
    if [[ -d "${CENTRAL_LIB}/tools" ]]; then
        echo ""
        echo -e "${BLUE}Tools${NC} (tools/)"
        for f in "${CENTRAL_LIB}/tools"/*.md; do
            [[ -f "$f" ]] || continue
            local name=$(basename "$f" .md)
            local lines=$(wc -l < "$f")
            printf "  %-30s %s\n" "$name" "${DIM}(${lines} lines)${NC}"
        done
    fi

    echo ""
}

#------------------------------------------------------------------------------
# Command: show
#------------------------------------------------------------------------------
cmd_show() {
    check_setup

    local project_path
    project_path=$(resolve_project "${1:-.}")

    if [[ ! -d "$project_path" ]]; then
        error "Not a directory: $project_path"
        exit 1
    fi

    local category
    category=$(get_category "$project_path")
    local project_name=$(basename "$project_path")
    local instr_dir="${project_path}/.github/instructions"

    echo ""
    echo -e "${CYAN}Project:${NC}  $project_name"
    echo -e "${CYAN}Category:${NC} $category"
    echo -e "${CYAN}Path:${NC}     $project_path"
    echo "────────────────────────────────────────"

    if [[ ! -d "$instr_dir" ]]; then
        warn "No .github/instructions/ directory"
        echo ""
        echo "Run: instr sync ."
        return
    fi

    echo ""
    echo -e "${BLUE}Loaded Instructions:${NC}"

    local symlinks=0
    local local_files=0
    local broken=0

    for f in "$instr_dir"/*.md; do
        [[ -e "$f" || -L "$f" ]] || continue
        local name=$(basename "$f")

        if [[ -L "$f" ]]; then
            local target=$(readlink "$f")
            if [[ -e "$f" ]]; then
                # Categorize the symlink
                if [[ "$target" == *"/core/"* ]]; then
                    printf "  ${GREEN}●${NC} %-35s ${DIM}core${NC}\n" "$name"
                elif [[ "$target" == *"/domains/"* ]]; then
                    local domain=$(echo "$target" | sed 's|.*/domains/\([^/]*\)/.*|\1|')
                    printf "  ${GREEN}●${NC} %-35s ${DIM}domain:$domain${NC}\n" "$name"
                elif [[ "$target" == *"/tools/"* ]]; then
                    printf "  ${GREEN}●${NC} %-35s ${DIM}tool${NC}\n" "$name"
                else
                    printf "  ${GREEN}●${NC} %-35s ${DIM}symlink${NC}\n" "$name"
                fi
                symlinks=$((symlinks + 1))
            else
                printf "  ${RED}✗${NC} %-35s ${RED}BROKEN${NC}\n" "$name"
                broken=$((broken + 1))
            fi
        else
            local lines=$(wc -l < "$f")
            printf "  ${YELLOW}◆${NC} %-35s ${DIM}local (${lines} lines)${NC}\n" "$name"
            local_files=$((local_files + 1))
        fi
    done

    echo ""
    echo -e "${DIM}Legend: ● symlink  ◆ local file  ✗ broken${NC}"
    echo -e "${DIM}Stats: $symlinks linked, $local_files local, $broken broken${NC}"
    echo ""
}

#------------------------------------------------------------------------------
# Command: sync
#------------------------------------------------------------------------------
cmd_sync() {
    check_setup

    local target="${1:-.}"

    if [[ "$target" == "--all" ]]; then
        error "--all not supported in generic mode"
        echo "Sync projects individually: instr sync /path/to/project"
        exit 1
    fi

    local project_path
    project_path=$(resolve_project "$target")
    sync_project "$project_path"
}

sync_project() {
    local project_path="$1"

    if [[ ! -d "$project_path" ]]; then
        error "Not a directory: $project_path"
        exit 1
    fi

    local category
    category=$(get_category "$project_path")
    local project_name=$(basename "$project_path")

    log "Syncing: $project_name (category: $category)"

    # Create instructions directory
    local instr_dir="${project_path}/.github/instructions"
    mkdir -p "$instr_dir"

    # Get instruction sets for this category
    local sets
    sets=$(get_default_sets "$category")

    local created=0

    for set in $sets; do
        [[ -z "$set" ]] && continue

        local type="${set%%:*}"
        local items="${set#*:}"

        IFS=',' read -ra ITEMS <<< "$items"
        for item in "${ITEMS[@]}"; do
            [[ -z "$item" ]] && continue

            case $type in
                core)
                    local source="${CENTRAL_LIB}/core/${item}.md"
                    local target="${instr_dir}/${item}.md"
                    ;;
                domain)
                    # Link all files in the domain
                    local domain_dir="${CENTRAL_LIB}/domains/${item}"
                    if [[ -d "$domain_dir" ]]; then
                        for f in "$domain_dir"/*.md; do
                            [[ -f "$f" ]] || continue
                            local fname=$(basename "$f")
                            local dtarget="${instr_dir}/${item}-${fname}"
                            if [[ ! -e "$dtarget" ]]; then
                                local rel_path
                                rel_path=$(get_relative_path "$project_path" "$f")
                                ln -sf "$rel_path" "$dtarget"
                                created=$((created + 1))
                            fi
                        done
                    fi
                    continue
                    ;;
                tool)
                    local source="${CENTRAL_LIB}/tools/${item}.md"
                    local target="${instr_dir}/${item}.md"
                    ;;
            esac

            if [[ -f "$source" && ! -e "$target" ]]; then
                local rel_path
                rel_path=$(get_relative_path "$project_path" "$source")
                ln -sf "$rel_path" "$target"
                created=$((created + 1))
            fi
        done
    done

    success "Created $created symlinks"
}

#------------------------------------------------------------------------------
# Command: add
#------------------------------------------------------------------------------
cmd_add() {
    check_setup

    local project_path
    project_path=$(resolve_project "${1:-.}")
    local set="${2:-}"

    if [[ -z "$set" ]]; then
        error "Usage: instr add <project> <type:name>"
        echo "  Examples:"
        echo "    instr add . domain:web"
        echo "    instr add . tool:docker"
        echo "    instr add . core:coding-standards"
        exit 1
    fi

    local type="${set%%:*}"
    local name="${set#*:}"

    local instr_dir="${project_path}/.github/instructions"
    mkdir -p "$instr_dir"

    case $type in
        domain)
            local domain_dir="${CENTRAL_LIB}/domains/${name}"
            if [[ ! -d "$domain_dir" ]]; then
                error "Domain not found: $name"
                echo "Available domains:"
                ls -1 "${CENTRAL_LIB}/domains/" 2>/dev/null || echo "  (none)"
                exit 1
            fi
            log "Adding domain: $name"
            for f in "$domain_dir"/*.md; do
                [[ -f "$f" ]] || continue
                local fname=$(basename "$f")
                local target="${instr_dir}/${name}-${fname}"
                if [[ ! -e "$target" ]]; then
                    local rel_path
                    rel_path=$(get_relative_path "$project_path" "$f")
                    ln -sf "$rel_path" "$target"
                    success "Linked: ${name}-${fname}"
                else
                    dim "  Already exists: ${name}-${fname}"
                fi
            done
            ;;
        tool)
            local source="${CENTRAL_LIB}/tools/${name}.md"
            if [[ ! -f "$source" ]]; then
                error "Tool not found: $name"
                echo "Available tools:"
                ls -1 "${CENTRAL_LIB}/tools/" 2>/dev/null | sed 's/.md$//' || echo "  (none)"
                exit 1
            fi
            local target="${instr_dir}/${name}.md"
            if [[ ! -e "$target" ]]; then
                local rel_path
                rel_path=$(get_relative_path "$project_path" "$source")
                ln -sf "$rel_path" "$target"
                success "Linked: ${name}.md"
            else
                warn "Already exists: ${name}.md"
            fi
            ;;
        core)
            local source="${CENTRAL_LIB}/core/${name}.md"
            if [[ ! -f "$source" ]]; then
                error "Core file not found: $name"
                echo "Available core files:"
                ls -1 "${CENTRAL_LIB}/core/" 2>/dev/null | sed 's/.md$//' || echo "  (none)"
                exit 1
            fi
            local target="${instr_dir}/${name}.md"
            if [[ ! -e "$target" ]]; then
                local rel_path
                rel_path=$(get_relative_path "$project_path" "$source")
                ln -sf "$rel_path" "$target"
                success "Linked: ${name}.md"
            else
                warn "Already exists: ${name}.md"
            fi
            ;;
        *)
            error "Unknown type: $type (use domain, tool, or core)"
            exit 1
            ;;
    esac
}

#------------------------------------------------------------------------------
# Command: remove
#------------------------------------------------------------------------------
cmd_remove() {
    local project_path
    project_path=$(resolve_project "${1:-.}")
    local file="${2:-}"

    if [[ -z "$file" ]]; then
        error "Usage: instr remove <project> <filename>"
        exit 1
    fi

    local instr_dir="${project_path}/.github/instructions"
    local target="${instr_dir}/${file}"

    # Add .md if not present
    [[ "$target" == *.md ]] || target="${target}.md"

    if [[ ! -e "$target" && ! -L "$target" ]]; then
        error "File not found: $file"
        exit 1
    fi

    if [[ -L "$target" ]]; then
        rm "$target"
        success "Removed symlink: $file"
    else
        warn "This is a local file, not a symlink: $file"
        read -p "Delete anyway? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            rm "$target"
            success "Removed: $file"
        fi
    fi
}

#------------------------------------------------------------------------------
# Command: pick
#------------------------------------------------------------------------------
cmd_pick() {
    check_setup

    local project_path
    project_path=$(resolve_project "${1:-.}")

    if [[ ! -d "$project_path" ]]; then
        error "Not a directory: $project_path"
        exit 1
    fi

    local instr_dir="${project_path}/.github/instructions"
    mkdir -p "$instr_dir"

    # Build list of available instructions with numbers
    local items=()
    local idx=1

    echo ""
    echo -e "${CYAN}Available Instructions${NC}"
    echo "────────────────────────────────────────"

    # Core files
    if [[ -d "${CENTRAL_LIB}/core" ]]; then
        echo -e "\n${BLUE}Core${NC}"
        for f in "${CENTRAL_LIB}/core"/*.md; do
            [[ -f "$f" ]] || continue
            local name=$(basename "$f" .md)
            local target="${instr_dir}/${name}.md"
            local status=""
            [[ -e "$target" ]] && status="${DIM}(loaded)${NC}"
            printf "  %3d) %-30s %s\n" "$idx" "core:$name" "$status"
            items+=("core:$name:$f")
            idx=$((idx + 1))
        done
    fi

    # Domain files
    if [[ -d "${CENTRAL_LIB}/domains" ]]; then
        echo -e "\n${BLUE}Domains${NC}"
        for domain_dir in "${CENTRAL_LIB}/domains"/*/; do
            [[ -d "$domain_dir" ]] || continue
            local domain=$(basename "$domain_dir")
            echo -e "  ${GREEN}$domain/${NC}"
            for f in "$domain_dir"*.md; do
                [[ -f "$f" ]] || continue
                local name=$(basename "$f" .md)
                local target="${instr_dir}/${domain}-${name}.md"
                local status=""
                [[ -e "$target" ]] && status="${DIM}(loaded)${NC}"
                printf "  %3d)   %-28s %s\n" "$idx" "domain:$domain/$name" "$status"
                items+=("domain:$domain/$name:$f")
                idx=$((idx + 1))
            done
        done
    fi

    # Tool files
    if [[ -d "${CENTRAL_LIB}/tools" ]]; then
        echo -e "\n${BLUE}Tools${NC}"
        for f in "${CENTRAL_LIB}/tools"/*.md; do
            [[ -f "$f" ]] || continue
            local name=$(basename "$f" .md)
            local target="${instr_dir}/${name}.md"
            local status=""
            [[ -e "$target" ]] && status="${DIM}(loaded)${NC}"
            printf "  %3d) %-30s %s\n" "$idx" "tool:$name" "$status"
            items+=("tool:$name:$f")
            idx=$((idx + 1))
        done
    fi

    echo ""
    echo -e "${DIM}Enter numbers separated by spaces (e.g., 1 3 5) or 'q' to quit:${NC}"
    read -r -p "> " selection

    [[ "$selection" == "q" || -z "$selection" ]] && return

    # Process selections
    for num in $selection; do
        if [[ ! "$num" =~ ^[0-9]+$ ]]; then
            warn "Invalid selection: $num"
            continue
        fi

        local array_idx=$((num - 1))
        if [[ $array_idx -lt 0 || $array_idx -ge ${#items[@]} ]]; then
            warn "Out of range: $num"
            continue
        fi

        local item="${items[$array_idx]}"
        local type="${item%%:*}"
        local rest="${item#*:}"
        local path="${rest#*:}"
        local name_part="${rest%%:*}"

        case $type in
            core)
                local name="$name_part"
                local target="${instr_dir}/${name}.md"
                if [[ ! -e "$target" ]]; then
                    local rel_path
                    rel_path=$(get_relative_path "$project_path" "$path")
                    ln -sf "$rel_path" "$target"
                    success "Added: ${name}.md"
                else
                    dim "  Already loaded: ${name}.md"
                fi
                ;;
            domain)
                local domain="${name_part%%/*}"
                local name="${name_part#*/}"
                local target="${instr_dir}/${domain}-${name}.md"
                if [[ ! -e "$target" ]]; then
                    local rel_path
                    rel_path=$(get_relative_path "$project_path" "$path")
                    ln -sf "$rel_path" "$target"
                    success "Added: ${domain}-${name}.md"
                else
                    dim "  Already loaded: ${domain}-${name}.md"
                fi
                ;;
            tool)
                local name="$name_part"
                local target="${instr_dir}/${name}.md"
                if [[ ! -e "$target" ]]; then
                    local rel_path
                    rel_path=$(get_relative_path "$project_path" "$path")
                    ln -sf "$rel_path" "$target"
                    success "Added: ${name}.md"
                else
                    dim "  Already loaded: ${name}.md"
                fi
                ;;
        esac
    done
}

#------------------------------------------------------------------------------
# Command: upload
#------------------------------------------------------------------------------
cmd_upload() {
    check_setup

    local file="${1:-}"
    local domain="${2:-}"

    if [[ -z "$file" || -z "$domain" ]]; then
        error "Usage: instr upload <file> <domain>"
        echo ""
        echo "Moves a local instruction file to the central library."
        echo ""
        echo "Examples:"
        echo "  instr upload my-config.md web"
        echo "  instr upload ./local-file.md backend"
        echo ""
        echo "Available domains:"
        ls -1 "${CENTRAL_LIB}/domains/" 2>/dev/null || echo "  (none - create with mkdir)"
        exit 1
    fi

    # Resolve file path
    local source_file
    if [[ "$file" == /* ]]; then
        source_file="$file"
    else
        source_file="$(pwd)/$file"
    fi

    if [[ ! -f "$source_file" ]]; then
        error "File not found: $file"
        exit 1
    fi

    # Check domain exists
    local domain_dir="${CENTRAL_LIB}/domains/${domain}"
    if [[ ! -d "$domain_dir" ]]; then
        warn "Domain '$domain' doesn't exist. Create it?"
        read -p "[y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            mkdir -p "$domain_dir"
            success "Created domain: $domain"
        else
            exit 1
        fi
    fi

    # Determine target filename
    local filename=$(basename "$source_file")
    # Ensure .md extension
    [[ "$filename" == *.md ]] || filename="${filename}.md"

    local target_file="${domain_dir}/${filename}"

    if [[ -f "$target_file" ]]; then
        error "File already exists in domain: $target_file"
        echo "Use a different name or manually merge the files."
        exit 1
    fi

    # Move file to central library
    log "Moving file to domains/${domain}/"
    mv "$source_file" "$target_file"
    success "Moved: $filename -> domains/${domain}/"

    # Create symlink in source project (where file came from)
    local source_dir=$(dirname "$source_file")
    if [[ "$source_dir" == */.github/instructions ]]; then
        local project_path=$(dirname "$(dirname "$source_dir")")
        local link_name="${domain}-$(basename "$filename" .md).md"
        local rel_path
        rel_path=$(get_relative_path "$project_path" "$target_file")
        ln -sf "$rel_path" "${source_dir}/${link_name}"
        success "Created symlink in source project: $link_name"
    fi

    echo ""
    echo -e "${DIM}File is now at: ${target_file}${NC}"
    echo -e "${DIM}Add to other projects with: instr add <project> domain:${domain}${NC}"
}

#------------------------------------------------------------------------------
# Command: check
#------------------------------------------------------------------------------
cmd_check() {
    local target="${1:-.}"

    if [[ "$target" == "--all" ]]; then
        error "--all not supported in generic mode"
        exit 1
    fi

    local project_path
    project_path=$(resolve_project "$target")
    local instr_dir="${project_path}/.github/instructions"

    if [[ ! -d "$instr_dir" ]]; then
        warn "No instructions directory"
        return
    fi

    local broken=0
    for f in "$instr_dir"/*.md; do
        if [[ -L "$f" && ! -e "$f" ]]; then
            error "Broken: $(basename "$f") -> $(readlink "$f")"
            broken=$((broken + 1))
        fi
    done

    if [[ $broken -eq 0 ]]; then
        success "All symlinks OK"
    else
        warn "$broken broken symlinks"
        echo "Run 'instr sync .' to recreate symlinks"
    fi
}

#------------------------------------------------------------------------------
# Command: audit
#------------------------------------------------------------------------------
cmd_audit() {
    local project_path
    project_path=$(resolve_project "${1:-.}")
    local instr_dir="${project_path}/.github/instructions"

    if [[ ! -d "$instr_dir" ]]; then
        warn "No instructions directory"
        return
    fi

    log "Auditing local instruction files..."
    echo ""

    local local_count=0
    for f in "$instr_dir"/*.md; do
        [[ -e "$f" ]] || continue
        [[ -L "$f" ]] && continue  # skip symlinks

        local name=$(basename "$f")
        local lines=$(wc -l < "$f")
        printf "  ${YELLOW}◆${NC} %-40s ${DIM}(%d lines)${NC}\n" "$name" "$lines"
        local_count=$((local_count + 1))
    done

    if [[ $local_count -eq 0 ]]; then
        success "No local files - all instructions are symlinked!"
    else
        echo ""
        echo -e "${DIM}Found $local_count local file(s)${NC}"
        echo ""
        echo "To centralize:"
        echo "  instr upload <filename> <domain>"
    fi
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------
show_help() {
    head -30 "$0" | grep -E "^#" | sed 's/^# \?//'
}

main() {
    local cmd="${1:-help}"
    shift || true

    case $cmd in
        list|ls)
            cmd_list "$@"
            ;;
        show|status)
            cmd_show "$@"
            ;;
        sync)
            cmd_sync "$@"
            ;;
        add)
            cmd_add "$@"
            ;;
        remove|rm)
            cmd_remove "$@"
            ;;
        pick)
            cmd_pick "$@"
            ;;
        upload)
            cmd_upload "$@"
            ;;
        check)
            cmd_check "$@"
            ;;
        audit)
            cmd_audit "$@"
            ;;
        help|-h|--help)
            show_help
            ;;
        *)
            error "Unknown command: $cmd"
            show_help
            exit 1
            ;;
    esac
}

main "$@"
